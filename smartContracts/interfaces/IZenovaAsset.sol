// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.8.0. SEE SOURCE BELOW. !!
pragma solidity ^0.8.19;

interface IZenovaAsset {
    function AI_ROLE() external view returns (bytes32);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);

    function LIQUIDITY_MANAGER_ROLE() external view returns (bytes32);

    function PRICE_AI_ROLE() external view returns (bytes32);

    function activateTrading() external;

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function assetPricingDetails()
        external
        view
        returns (
            uint256 currentPricePerToken,
            uint256 buyFeeBPS,
            uint256 sellFfeeBPS,
            uint256 marketCap,
            uint256 lastPriceUpdateTimestamp,
            address acceptedCurrency
        );

    function balanceOf(address account) external view returns (uint256);

    function buyTokens(uint256 tokenAmountToBuy) external payable;

    function collectedFees() external view returns (uint256);

    function companyInfo()
        external
        view
        returns (
            string memory name,
            string memory symbol,
            string memory description,
            string memory website,
            address issuingCompanyWallet
        );

    function companyWithdraw(uint256 amountOfTokens) external;

    function currentValuation() external view returns (uint256);

    function deactivateTrading() external;

    function decimals() external view returns (uint8);

    function getAssetPricingDetails()
        external
        view
        returns (ZenovaAsset.AssetPricingDetails memory);

    function getAssetSnapshot()
        external
        view
        returns (
            uint256 currentPrice,
            uint256 totalSupply,
            uint256 marketCap,
            uint256 contractBalance,
            bool isTradingActive,
            uint256 lastPriceUpdate
        );

    function getBuyQuote(uint256 tokenAmount)
        external
        view
        returns (uint256 totalCost, uint256 fee);

    function getCollectedFees() external view returns (uint256);

    function getCompanyInfo()
        external
        view
        returns (ZenovaAsset.CompanyInfo memory);

    function getFullAssetDetails()
        external
        view
        returns (ZenovaAsset.FullAssetDetails memory info);

    function getMarketAnalysis()
        external
        view
        returns (ZenovaAsset.MarketAnalysis memory analysis);

    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    function getRoleMember(bytes32 role, uint256 index)
        external
        view
        returns (address);

    function getRoleMemberCount(bytes32 role) external view returns (uint256);

    function getRoleMembers(bytes32 role)
        external
        view
        returns (address[] memory);

    function getSellQuote(uint256 tokenAmount)
        external
        view
        returns (uint256 proceeds, uint256 fee);

    function getTradingMetrics()
        external
        view
        returns (ZenovaAsset.TradingMetrics memory metrics);

    function getUserAssetInfo(address user)
        external
        view
        returns (ZenovaAsset.UserAssetInfo memory userInfo);

    function grantRole(bytes32 role, address account) external;

    function hasRole(bytes32 role, address account)
        external
        view
        returns (bool);

    function initialize(
        address _initialAdmin,
        ZenovaAsset.CompanyInfo memory _companyInfoStruct,
        address _acceptedCurrency
    ) external;

    function isTradingActive() external view returns (bool);

    function lastTradeTimestamp() external view returns (uint256);

    function maxTokenSupply() external view returns (uint256);

    function name() external view returns (string memory);

    function pause() external;

    function paused() external view returns (bool);

    function renounceRole(bytes32 role, address callerConfirmation) external;

    function revokeRole(bytes32 role, address account) external;

    function sellTokens(uint256 tokenAmountToSell) external;

    function setCompanyValuationAndSupply(
        uint256 _companyValuation,
        uint256 _initialPricePerToken,
        address _evaluator
    ) external;

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    function symbol() external view returns (string memory);

    function totalBuyTransactions() external view returns (uint256);

    function totalSellTransactions() external view returns (uint256);

    function totalSupply() external view returns (uint256);

    function totalTokensTraded() external view returns (uint256);

    function totalVolumeTraded() external view returns (uint256);

    function tradingActive() external view returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function unpause() external;

    function updateLiquidityParameters(
        uint256 newBuyFeeBPS,
        uint256 newSellFeeBPS
    ) external;

    function updatePrice(uint256 newPricePerToken) external;

    function userHasTraded(address) external view returns (bool);

    function userLastTradeTimestamp(address) external view returns (uint256);

    function userTotalFeesPaid(address) external view returns (uint256);

    function userTotalPurchaseValue(address) external view returns (uint256);

    function userTotalSaleValue(address) external view returns (uint256);

    function withdrawFees(address recipient) external;

    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
    event CompanyValuationSet(
        uint256 valuation,
        uint256 maxSupply,
        address evaluator
    );
    event LiquidityParametersUpdated(
        uint256 buyFeeBPS,
        uint256 sellFeeBPS,
        address updater
    );
    event Paused(address account);
    event PriceUpdated(uint256 newPrice, address updater);
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );
    event TradeExecuted(
        address indexed trader,
        bool isBuy,
        uint256 tokenAmount,
        uint256 currencyAmount,
        uint256 fee
    );
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unpaused(address account);
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error ERC20InsufficientAllowance(
        address spender,
        uint256 allowance,
        uint256 needed
    );
    error ERC20InsufficientBalance(
        address sender,
        uint256 balance,
        uint256 needed
    );
    error ERC20InvalidApprover(address approver);
    error ERC20InvalidReceiver(address receiver);
    error ERC20InvalidSender(address sender);
    error ERC20InvalidSpender(address spender);
    error EnforcedPause();
    error ExpectedPause();
    error SafeERC20FailedOperation(address token);
    error ZenovaAsset__AlreadyInitialized();
    error ZenovaAsset__CompanyWalletNotSet();
    error ZenovaAsset__FeeTooHigh(uint256 feeBPS);
    error ZenovaAsset__InsufficientAllowance(
        address token,
        address spender,
        uint256 needed
    );
    error ZenovaAsset__InsufficientOutputAmount();
    error ZenovaAsset__InvalidAmount();
    error ZenovaAsset__MaxSupplyReached();
    error ZenovaAsset__MaxSupplyWouldBeZero();
    error ZenovaAsset__NoFeesToWithdraw();
    error ZenovaAsset__NotInitialized();
    error ZenovaAsset__PriceMustBePositive();
    error ZenovaAsset__TradingActive();
    error ZenovaAsset__TradingNotActive();
    error ZenovaAsset__TransferFailed(
        address token,
        address recipient,
        uint256 amount
    );
    error ZenovaAsset__ValuationNotSet();
    error ZenovaAsset__ValuationZeroOrPriceZero();
    error ZenovaAsset__WithdrawAmountExceedsBalance();
    error ZenovaAsset__ZeroAddress();
    error ZenovaRoles__NotAI();
}

interface ZenovaAsset {
    struct AssetPricingDetails {
        uint256 currentPricePerToken;
        uint256 buyFeeBPS;
        uint256 sellFeeBPS;
        uint256 marketCap;
        uint256 lastPriceUpdateTimestamp;
        address acceptedCurrency;
    }

    struct CompanyInfo {
        string name;
        string symbol;
        string description;
        string website;
        address issuingCompanyWallet;
    }

    struct FullAssetDetails {
        address assetAddress;
        CompanyInfo companyDetails;
        AssetPricingDetails pricingDetails;
        uint256 currentValuation;
        uint256 maxTokenSupply;
        uint256 currentTotalSupply;
        bool isTradingActive;
        address admin;
        address priceAI;
        address liquidityManager;
    }

    struct MarketAnalysis {
        uint256 currentMarketCap;
        uint256 fullyDilutedMarketCap;
        uint256 circulationRatio;
        uint256 liquidityRatio;
        uint256 priceToValuationRatio;
        bool isOvervalued;
        bool isUndervalued;
        uint256 timeSinceLastPriceUpdate;
    }

    struct TradingMetrics {
        uint256 totalVolumeTraded;
        uint256 totalTokensTraded;
        uint256 totalBuyTransactions;
        uint256 totalSellTransactions;
        uint256 totalFeesCollected;
        uint256 averageTradeSize;
        uint256 lastTradeTimestamp;
        uint256 priceVolatility;
    }

    struct UserAssetInfo {
        uint256 tokenBalance;
        uint256 tokenBalanceValue;
        uint256 percentageOfSupply;
        uint256 totalPurchaseValue;
        uint256 totalSaleValue;
        uint256 totalFeesPaid;
        uint256 lastTradeTimestamp;
        bool hasTraded;
        uint256 realizedPnL;
        uint256 unrealizedPnL;
    }
}
